
document.addEventListener('DOMContentLoaded', () => {
    try {
        console.log('App initialized');
        // Initialize Rest buttons
        // Initialize Rest Buttons
        initRestButtons();
        // Initialize Sliders
        initSliders();
        // --- State Management ---

        const STORAGE_KEY = 'harada_method_app_data_v1';

        let appState = {
            goal: '',
            deadline: '',
            fourViews: {
                selfTangible: '',
                selfIntangible: '',
                societyTangible: '',
                societyIntangible: ''
            },
            milestones: { // New
                days3: '',
                week1: '',
                month1: '',
                month3: '',
                month6: '',
                year1: ''
            },
            // KPIs for SMART goals
            kpis: [
                { name: '', current: '', target: '', unit: '', history: [] },
                { name: '', current: '', target: '', unit: '', history: [] },
                { name: '', current: '', target: '', unit: '', history: [] }
            ],
            // Supporters
            supporters: [
                { name: '', do: '', dont: '' },
                { name: '', do: '', dont: '' },
                { name: '', do: '', dont: '' },
                { name: '', do: '', dont: '' }
            ],
            // Mental Control
            mental: {
                declaration: '',
                selftalk: '',
                improvement: '',
                reset: ''
            },
            // Mandala: 9 blocks
            mandala: Array(9).fill(null).map(() => Array(9).fill('')),
            routines: [], // { id, text }
            logs: {}, // { 'YYYY-MM-DD': { routineId: boolean } }
            sprintGoals: [] // { id, text, deadline, completed }
        };

        function loadState() {
            const stored = localStorage.getItem(STORAGE_KEY);
            if (stored) {
                try {
                    const parsed = JSON.parse(stored);
                    appState = { ...appState, ...parsed };
                    // Ensure array structures
                    if (!appState.mandala || appState.mandala.length !== 9) {
                        appState.mandala = Array(9).fill(null).map(() => Array(9).fill(''));
                    }
                    if (!appState.sprintGoals) appState.sprintGoals = [];
                    if (!appState.milestones) appState.milestones = {};
                    if (!appState.supporters) {
                        appState.supporters = [
                            { name: '', do: '', dont: '' },
                            { name: '', do: '', dont: '' },
                            { name: '', do: '', dont: '' },
                            { name: '', do: '', dont: '' }
                        ];
                    }
                    if (!appState.mental) {
                        appState.mental = { declaration: '', selftalk: '', improvement: '', reset: '' };
                    }
                } catch (e) {
                    console.error('Failed to parse state', e);
                }
            }
        }

        function saveState() {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(appState));
            updateDashboard();
        }

        // --- Navigation ---
        const navLinksContainer = document.getElementById('nav-links');
        let navItems = document.querySelectorAll('.nav-item');
        const sections = document.querySelectorAll('.page-section');
        const NAV_ORDER_KEY = 'harada_nav_order';

        // Load saved nav order
        function loadNavOrder() {
            const savedOrder = localStorage.getItem(NAV_ORDER_KEY);
            if (savedOrder && navLinksContainer) {
                try {
                    const order = JSON.parse(savedOrder);
                    const items = Array.from(navLinksContainer.children);
                    order.forEach(targetId => {
                        const item = items.find(el => el.getAttribute('data-target') === targetId);
                        if (item) navLinksContainer.appendChild(item);
                    });
                    // Re-query after reorder
                    navItems = document.querySelectorAll('.nav-item');
                } catch (e) {
                    console.error('Failed to load nav order', e);
                }
            }
        }

        // Save nav order
        function saveNavOrder() {
            if (!navLinksContainer) return;
            const order = Array.from(navLinksContainer.children).map(el => el.getAttribute('data-target'));
            localStorage.setItem(NAV_ORDER_KEY, JSON.stringify(order));
        }

        // Drag and drop for nav items
        let draggedItem = null;

        function initNavDragDrop() {
            navItems.forEach(item => {
                item.addEventListener('dragstart', (e) => {
                    draggedItem = item;
                    item.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                });

                item.addEventListener('dragend', () => {
                    item.classList.remove('dragging');
                    document.querySelectorAll('.nav-item').forEach(i => i.classList.remove('drag-over'));
                    saveNavOrder();
                    draggedItem = null;
                });

                item.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    if (draggedItem && draggedItem !== item) {
                        item.classList.add('drag-over');
                    }
                });

                item.addEventListener('dragleave', () => {
                    item.classList.remove('drag-over');
                });

                item.addEventListener('drop', (e) => {
                    e.preventDefault();
                    item.classList.remove('drag-over');
                    if (draggedItem && draggedItem !== item && navLinksContainer) {
                        const allItems = Array.from(navLinksContainer.children);
                        const draggedIndex = allItems.indexOf(draggedItem);
                        const targetIndex = allItems.indexOf(item);

                        if (draggedIndex < targetIndex) {
                            navLinksContainer.insertBefore(draggedItem, item.nextSibling);
                        } else {
                            navLinksContainer.insertBefore(draggedItem, item);
                        }
                    }
                });

                // Click handler for navigation
                item.addEventListener('click', (e) => {
                    // Don't navigate if clicking drag handle
                    if (e.target.classList.contains('drag-handle')) return;

                    const targetId = item.getAttribute('data-target');
                    document.querySelectorAll('.nav-item').forEach(nav => nav.classList.remove('active'));
                    item.classList.add('active');
                    sections.forEach(sec => {
                        sec.classList.remove('active');
                        if (sec.id === targetId) {
                            sec.classList.add('active');
                            if (targetId === 'dashboard') updateDashboard();
                            if (targetId === 'mandala') renderMandala();
                            if (targetId === 'sprint-goals') renderSprintGoals();
                        }
                    });
                });
            });
        }

        loadNavOrder();
        initNavDragDrop();

        // --- Settings & Config (Moved to top for priority) ---
        const userProfileBtn = document.querySelector('.user-profile');
        const settingsModal = document.getElementById('settings-modal');
        const btnCloseSettings = document.getElementById('btn-close-settings');
        const btnSaveSettings = document.getElementById('btn-save-settings');
        const configGasUrl = document.getElementById('config-gas-url');
        const configNotebookUrl = document.getElementById('config-notebook-url');
        const configGeminiKey = document.getElementById('config-gemini-key');
        const CONFIG_KEY = 'nld_config';

        if (userProfileBtn) {
            userProfileBtn.addEventListener('click', async () => {
                console.log('User Profile Clicked');
                if (typeof chrome !== 'undefined' && chrome.storage) {
                    const result = await chrome.storage.local.get(CONFIG_KEY);
                    const config = result[CONFIG_KEY] || {};
                    if (configGasUrl) configGasUrl.value = config.gasUrl || '';
                    if (configNotebookUrl) configNotebookUrl.value = config.notebookUrl || '';
                    if (configGeminiKey) configGeminiKey.value = config.geminiApiKey || '';
                }
                if (settingsModal) settingsModal.classList.add('open');
            });
        }
        if (btnCloseSettings) btnCloseSettings.addEventListener('click', () => settingsModal.classList.remove('open'));
        if (btnSaveSettings) {
            btnSaveSettings.addEventListener('click', async () => {
                const config = {
                    gasUrl: configGasUrl ? configGasUrl.value : '',
                    notebookUrl: configNotebookUrl ? configNotebookUrl.value : '',
                    geminiApiKey: configGeminiKey ? configGeminiKey.value : ''
                };
                if (typeof chrome !== 'undefined' && chrome.storage) {
                    await chrome.storage.local.set({ [CONFIG_KEY]: config });
                    alert('Ë®≠ÂÆö„Çí‰øùÂ≠ò„Åó„Åæ„Åó„Åü');
                    settingsModal.classList.remove('open');
                } else {
                    alert('Êã°ÂºµÊ©üËÉΩÂ§ñ„ÄÅ„Åæ„Åü„ÅØ„Çπ„Éà„É¨„Éº„Ç∏Ê®©Èôê„Åå„ÅÇ„Çä„Åæ„Åõ„Çì');
                }
            });
        }

        // --- Goal Setting Logic ---
        const goalInput = document.getElementById('goal-input');
        const deadlineInput = document.getElementById('deadline-input');
        const viewInputs = {
            selfTangible: document.getElementById('view-self-tangible'),
            selfIntangible: document.getElementById('view-self-intangible'),
            societyTangible: document.getElementById('view-society-tangible'),
            societyIntangible: document.getElementById('view-society-intangible')
        };
        // Milestones Inputs
        const milestoneInputs = {
            days3: document.getElementById('milestone-3days'),
            week1: document.getElementById('milestone-1week'),
            month1: document.getElementById('milestone-1month'),
            month3: document.getElementById('milestone-3months'),
            month6: document.getElementById('milestone-6months'),
            year1: document.getElementById('milestone-1year')
        };

        const saveGoalBtn = document.getElementById('save-goal-btn');

        function initGoalForm() {
            if (appState.goal) goalInput.value = appState.goal;
            if (appState.deadline) deadlineInput.value = appState.deadline;
            if (appState.fourViews) {
                if (viewInputs.selfTangible) viewInputs.selfTangible.value = appState.fourViews.selfTangible || '';
                if (viewInputs.selfIntangible) viewInputs.selfIntangible.value = appState.fourViews.selfIntangible || '';
                if (viewInputs.societyTangible) viewInputs.societyTangible.value = appState.fourViews.societyTangible || '';
                if (viewInputs.societyIntangible) viewInputs.societyIntangible.value = appState.fourViews.societyIntangible || '';
            }
            if (appState.milestones) {
                if (milestoneInputs.days3) milestoneInputs.days3.value = appState.milestones.days3 || '';
                if (milestoneInputs.week1) milestoneInputs.week1.value = appState.milestones.week1 || '';
                if (milestoneInputs.month1) milestoneInputs.month1.value = appState.milestones.month1 || '';
                if (milestoneInputs.month3) milestoneInputs.month3.value = appState.milestones.month3 || '';
                if (milestoneInputs.month6) milestoneInputs.month6.value = appState.milestones.month6 || '';
                if (milestoneInputs.year1) milestoneInputs.year1.value = appState.milestones.year1 || '';
            }
            // Render KPIs dynamically
            renderKpis();
        }

        // ========================================
        // KPI DYNAMIC RENDERING SYSTEM
        // ========================================
        const kpiContainer = document.getElementById('kpi-container');
        const addKpiBtn = document.getElementById('add-kpi-btn');

        function createKpiElement(index, kpi = {}) {
            const div = document.createElement('div');
            div.className = 'kpi-item';
            div.dataset.index = index;
            div.innerHTML = `
                <div class="kpi-header">
                    <span class="kpi-badge">KPI ${index + 1}</span>
                    <input type="text" class="kpi-name-input" data-field="name" placeholder="‰æãÔºöTOEIC" value="${kpi.name || ''}">
                    <button class="kpi-delete-btn" title="ÂâäÈô§"><i class="fa-solid fa-trash"></i></button>
                </div>
                <div class="kpi-values">
                    <div class="kpi-value-group">
                        <label>ÁèæÂú®ÂÄ§</label>
                        <input type="number" class="kpi-number-input" data-field="current" placeholder="0" value="${kpi.current || ''}">
                    </div>
                    <div class="kpi-arrow">‚Üí</div>
                    <div class="kpi-value-group">
                        <label>ÁõÆÊ®ôÂÄ§</label>
                        <input type="number" class="kpi-number-input" data-field="target" placeholder="100" value="${kpi.target || ''}">
                    </div>
                    <div class="kpi-value-group">
                        <label>Âçò‰Ωç</label>
                        <input type="text" class="kpi-unit-input" data-field="unit" placeholder="ÁÇπ" value="${kpi.unit || ''}">
                    </div>
                    <div class="kpi-value-group">
                        <label>ÊúüÊó•</label>
                        <input type="date" class="kpi-date-input" data-field="deadline" value="${kpi.deadline || ''}">
                    </div>
                </div>
                <div class="kpi-progress-bar">
                    <div class="kpi-progress-fill" style="width: 0%"></div>
                </div>
            `;

            // Add event listeners
            const currentInput = div.querySelector('[data-field="current"]');
            const targetInput = div.querySelector('[data-field="target"]');
            const deleteBtn = div.querySelector('.kpi-delete-btn');

            currentInput.addEventListener('input', () => updateKpiProgressForElement(div));
            targetInput.addEventListener('input', () => updateKpiProgressForElement(div));
            deleteBtn.addEventListener('click', () => deleteKpi(index));

            // Initial progress update
            setTimeout(() => updateKpiProgressForElement(div), 0);

            return div;
        }

        function updateKpiProgressForElement(element) {
            const currentInput = element.querySelector('[data-field="current"]');
            const targetInput = element.querySelector('[data-field="target"]');
            const progressFill = element.querySelector('.kpi-progress-fill');
            if (!currentInput || !targetInput || !progressFill) return;

            const current = parseFloat(currentInput.value) || 0;
            const target = parseFloat(targetInput.value) || 0;

            if (target === 0) {
                progressFill.style.width = '0%';
                return;
            }

            let progress;
            if (target > current) {
                progress = (current / target) * 100;
            } else if (target < current) {
                // Decrease goal (e.g., weight)
                const startValue = current;
                progress = ((startValue - current) / (startValue - target)) * 100;
                // If current is already at or below target, 100%
                if (current <= target) progress = 100;
            } else {
                progress = 100;
            }
            progress = Math.max(0, Math.min(100, progress));
            progressFill.style.width = `${progress}%`;
        }

        function renderKpis() {
            if (!kpiContainer) return;
            kpiContainer.innerHTML = '';

            // Ensure kpis array exists
            if (!appState.kpis || appState.kpis.length === 0) {
                appState.kpis = [{ name: '', current: '', target: '', unit: '', history: [] }];
            }

            appState.kpis.forEach((kpi, index) => {
                const element = createKpiElement(index, kpi);
                kpiContainer.appendChild(element);
            });
        }

        function addKpi() {
            if (!appState.kpis) appState.kpis = [];
            appState.kpis.push({ name: '', current: '', target: '', unit: '', history: [] });
            renderKpis();
        }

        function deleteKpi(index) {
            if (appState.kpis.length <= 1) {
                alert('ÊúÄ‰Ωé1„Å§„ÅÆKPI„ÅåÂøÖË¶Å„Åß„Åô');
                return;
            }
            appState.kpis.splice(index, 1);
            renderKpis();
        }

        function collectKpisFromUI() {
            const items = kpiContainer ? kpiContainer.querySelectorAll('.kpi-item') : [];
            const kpis = [];
            items.forEach((item, index) => {
                const name = item.querySelector('[data-field="name"]')?.value || '';
                const current = item.querySelector('[data-field="current"]')?.value || '';
                const target = item.querySelector('[data-field="target"]')?.value || '';
                const unit = item.querySelector('[data-field="unit"]')?.value || '';
                const deadline = item.querySelector('[data-field="deadline"]')?.value || '';

                // Preserve history from existing state
                const existingHistory = appState.kpis[index]?.history || [];

                // Add today's value to history if changed
                const today = new Date().toISOString().split('T')[0];
                const currentValue = parseFloat(current);
                let history = [...existingHistory];

                if (!isNaN(currentValue)) {
                    const lastEntry = history[history.length - 1];
                    if (!lastEntry || lastEntry.date !== today) {
                        history.push({ date: today, value: currentValue });
                    } else {
                        lastEntry.value = currentValue;
                    }
                }

                kpis.push({ name, current, target, unit, deadline, history });
            });
            return kpis;
        }

        // Add KPI button listener
        if (addKpiBtn) {
            addKpiBtn.addEventListener('click', addKpi);
        }

        // Legacy function for compatibility
        function updateKpiProgress(index) {
            const items = kpiContainer ? kpiContainer.querySelectorAll('.kpi-item') : [];
            if (items[index]) updateKpiProgressForElement(items[index]);
        }

        if (saveGoalBtn) saveGoalBtn.addEventListener('click', () => {
            appState.goal = goalInput.value;
            appState.deadline = deadlineInput.value;
            if (viewInputs.selfTangible) appState.fourViews.selfTangible = viewInputs.selfTangible.value;
            if (viewInputs.selfIntangible) appState.fourViews.selfIntangible = viewInputs.selfIntangible.value;
            if (viewInputs.societyTangible) appState.fourViews.societyTangible = viewInputs.societyTangible.value;
            if (viewInputs.societyIntangible) appState.fourViews.societyIntangible = viewInputs.societyIntangible.value;

            // Save Milestones
            appState.milestones = {
                days3: milestoneInputs.days3 ? milestoneInputs.days3.value : '',
                week1: milestoneInputs.week1 ? milestoneInputs.week1.value : '',
                month1: milestoneInputs.month1 ? milestoneInputs.month1.value : '',
                month3: milestoneInputs.month3 ? milestoneInputs.month3.value : '',
                month6: milestoneInputs.month6 ? milestoneInputs.month6.value : '',
                year1: milestoneInputs.year1 ? milestoneInputs.year1.value : ''
            };

            // Save KPIs (dynamic)
            appState.kpis = collectKpisFromUI();

            // Sync Main Goal to Mandala
            appState.mandala[4][4] = appState.goal;

            saveState();
            alert('ÁõÆÊ®ôË®≠ÂÆö„Çí‰øùÂ≠ò„Åó„Åæ„Åó„Åü');
        });

        // ... (Sprint Goals remains same) ...
        // Note: To preserve context perfectly, I will skip re-outputting Sprint Logic here as it's separate.
        // The previous replace call might require me to bridge this gap carefully.
        // Let me just ensure the replaced block connects correctly.
        // WAIT, I need to update the AI Wizard Logic further down too. 
        // I should probably target the specific AI Wizard block separately or include it here if contiguous.
        // Looking at file content, AI Logic starts at line 169.
        // My replace block ends before that. I will do AI logic in next step.

        // --- Sprint Goals (3 Days) Logic ---
        const sprintList = document.getElementById('sprint-list');
        const btnAddSprint = document.getElementById('btn-add-sprint-goal');

        function renderSprintGoals() {
            if (!sprintList) return;
            sprintList.innerHTML = '';
            const now = new Date();
            const todayStr = now.toISOString().split('T')[0];

            if (appState.sprintGoals.length === 0) {
                sprintList.innerHTML = '<div class="empty-state">Áõ¥Ëøë3Êó•Èñì„ÅßÈÅîÊàê„Åó„Åü„ÅÑ„Åì„Å®„ÇíÁôªÈå≤„Åó„Åæ„Åó„Çá„ÅÜ</div>';
                return;
            }

            appState.sprintGoals.forEach(sg => {
                const div = document.createElement('div');
                div.className = 'sprint-item';
                div.innerHTML = `
                <div class="sprint-check ${sg.completed ? 'checked' : ''}" data-id="${sg.id}">
                    <i class="fa-solid fa-check"></i>
                </div>
                <div class="sprint-content">
                    <div class="sprint-text ${sg.completed ? 'checked' : ''}">${sg.text}</div>
                    <div class="sprint-meta">ÊúüÈôê: ${sg.deadline || '„Å™„Åó'}</div>
                </div>
                <div class="sprint-delete" data-id="${sg.id}"><i class="fa-solid fa-trash"></i></div>
            `;

                // Toggle Check
                div.querySelector('.sprint-check').addEventListener('click', () => {
                    sg.completed = !sg.completed;
                    saveState();
                    renderSprintGoals();
                });

                // Delete
                div.querySelector('.sprint-delete').addEventListener('click', () => {
                    if (confirm('ÂâäÈô§„Åó„Å¶„ÇÇ„Çà„Çç„Åó„ÅÑ„Åß„Åô„ÅãÔºü')) {
                        appState.sprintGoals = appState.sprintGoals.filter(g => g.id !== sg.id);
                        saveState();
                        renderSprintGoals();
                    }
                });

                sprintList.appendChild(div);
            });
        }

        if (btnAddSprint) btnAddSprint.addEventListener('click', () => {
            const text = prompt('3Êó•‰ª•ÂÜÖ„Å´ÈÅîÊàê„Åó„Åü„ÅÑÁõÆÊ®ô„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ:');
            if (text) {
                const d = new Date();
                d.setDate(d.getDate() + 3);
                const deadlineStr = d.toISOString().split('T')[0];

                appState.sprintGoals.push({
                    id: Date.now().toString(),
                    text: text,
                    deadline: deadlineStr,
                    completed: false
                });
                saveState();
                renderSprintGoals();
            }
        });


        // --- AI Wizard Logic ---
        const btnOpenWizard = document.getElementById('btn-open-ai-wizard');
        const wizardModal = document.getElementById('ai-wizard-modal');
        const wizardContent = document.getElementById('wizard-content');
        const btnWizNext = document.getElementById('btn-wiz-next');
        const btnWizPrev = document.getElementById('btn-wiz-prev');
        const btnWizCancel = document.getElementById('btn-wiz-cancel');
        const btnWizSave = document.getElementById('btn-wiz-save'); // New
        const stepIndicators = document.querySelectorAll('.step-indicator .step');

        let currentWizStep = 1;
        let wizAnswers = {}; // Changed to let to allow reassignment
        const totalSteps = 5;

        const wizQuestions = [
            { id: 1, title: 'Q1. ÈÅîÊàê„Åó„Åü„ÅÑ„Åì„Å®', text: '„ÅÇ„Å™„Åü„Åå‰∏ÄÁï™ÈÅîÊàê„Åó„Åü„ÅÑÁõÆÊ®ôÔºàÂ§¢Ôºâ„ÅØ‰Ωï„Åß„Åô„ÅãÔºü', placeholder: '‰æãÔºöÂπ¥Âèé2000‰∏áÂÜÜ„ÄÅËã±Ë™û„Éö„É©„Éö„É©„ÄÅ„Éï„É´„Éû„É©„ÇΩ„É≥ÂÆåËµ∞...' },
            { id: 2, title: 'Q2. ÁõÆÁöÑ„ÉªÁêÜÁî±', text: '„Å™„Åú„Åù„Çå„ÇíÈÅîÊàê„Åó„Åü„ÅÑ„ÅÆ„Åß„Åô„ÅãÔºü„Åù„Çå„ÇíÈÅîÊàê„Åô„Çã„Å®„ÄÅ„Å©„Çì„Å™ËâØ„ÅÑ„Åì„Å®„Åå„ÅÇ„Çä„Åæ„Åô„ÅãÔºü', placeholder: '‰æãÔºöÂÆ∂Êóè„ÇíÊóÖË°å„Å´ÈÄ£„Çå„Å¶Ë°å„Åë„Çã„ÄÅËá™ÂàÜ„Å´Ëá™‰ø°„Åå„Å§„Åè...' },
            { id: 3, title: 'Q3. Ëá™ÂàÜ„ÅÆ„É°„É™„ÉÉ„ÉàÔºàÊúâÂΩ¢Ôºâ', text: 'ÈÅîÊàê„Åó„ÅüÊôÇ„ÄÅ„ÅÇ„Å™„ÅüËá™Ë∫´„ÅåÂæó„Çâ„Çå„Çã„ÄåÁõÆ„Å´Ë¶ã„Åà„Çã„ÇÇ„ÅÆ„Äç„ÅØ‰Ωï„Åß„Åô„ÅãÔºü', placeholder: '‰æãÔºöÊñ∞„Åó„ÅÑËªä„ÄÅË≤ØÈáë„ÄÅË≥ûÁä∂...' },
            { id: 4, title: 'Q4. Ëá™ÂàÜ„ÅÆÂ§âÂåñÔºàÁÑ°ÂΩ¢Ôºâ', text: 'ÈÅîÊàê„Åó„ÅüÊôÇ„ÄÅ„ÅÇ„Å™„Åü„ÅÆÂøÉ„ÇÑ„Çπ„Ç≠„É´„ÅØ„Å©„ÅÜÊàêÈï∑„Åó„Å¶„ÅÑ„Åæ„Åô„ÅãÔºü', placeholder: '‰æãÔºöËá™‰ø°„ÄÅÂøçËÄêÂäõ„ÄÅ„Éó„É¨„Çº„É≥„Çπ„Ç≠„É´...' },
            { id: 5, title: 'Q5. ‰ªñËÄÖ„Å∏„ÅÆË≤¢ÁåÆ', text: '„ÅÇ„Å™„Åü„Åå„Åù„Çå„ÇíÈÅîÊàê„Åô„Çã„Åì„Å®„Åß„ÄÅÂë®„Çä„ÅÆ‰∫∫„ÇÑÁ§æ‰ºö„Å´„Å©„Çì„Å™ËâØ„ÅÑÂΩ±Èüø„Åå„ÅÇ„Çä„Åæ„Åô„ÅãÔºü', placeholder: '‰æãÔºöÂÆ∂Êóè„ÅåÁ¨ëÈ°î„Å´„Å™„Çã„ÄÅÂæåËº©„ÅÆÁõÆÊ®ô„Å´„Å™„Çã...' }
        ];

        function renderWizardStep(step) {
            // Update Indicators
            stepIndicators.forEach((ind, idx) => {
                if (idx + 1 === step) ind.classList.add('active');
                else ind.classList.remove('active');
            });

            // Show Buttons
            btnWizPrev.style.display = step === 1 ? 'none' : 'block';
            btnWizNext.innerHTML = step === totalSteps ? 'ÁîüÊàê„Åô„Çã <i class="fa-solid fa-wand-magic-sparkles"></i>' : 'Ê¨°„Å∏ <i class="fa-solid fa-arrow-right"></i>';

            const q = wizQuestions[step - 1];
            wizardContent.innerHTML = `
            <div class="question-slide active">
                <h3>${q.title}</h3>
                <p>${q.text}</p>
                <textarea id="wiz-input-${step}" placeholder="${q.placeholder}" style="width:100%; height:120px;">${wizAnswers[step] || ''}</textarea>
            </div>
        `;
        }

        if (btnOpenWizard) {
            btnOpenWizard.addEventListener('click', () => {
                currentWizStep = 1;

                // Load Draft if exists
                const draft = localStorage.getItem('nld_wiz_draft');
                if (draft) {
                    try {
                        wizAnswers = JSON.parse(draft);
                    } catch (e) {
                        wizAnswers = {};
                    }
                } else {
                    wizAnswers = {};
                }

                renderWizardStep(1);
                wizardModal.classList.add('open');
            });
        }

        if (btnWizCancel) {
            btnWizCancel.addEventListener('click', () => {
                if (wizardModal) wizardModal.classList.remove('open');
            });
        }

        // Temp Save Logic
        if (btnWizSave) {
            btnWizSave.addEventListener('click', () => {
                // Save current step input first
                const input = document.getElementById(`wiz-input-${currentWizStep}`);
                if (input) wizAnswers[currentWizStep] = input.value;

                localStorage.setItem('nld_wiz_draft', JSON.stringify(wizAnswers));
                alert('ÂõûÁ≠î„Çí‰∏ÄÊôÇ‰øùÂ≠ò„Åó„Åæ„Åó„Åü„ÄÇ\nÊ¨°ÂõûÈñã„Åè„Å®„Åç„Å´Âæ©ÂÖÉ„Åï„Çå„Åæ„Åô„ÄÇ');
            });
        }

        if (btnWizPrev) {
            btnWizPrev.addEventListener('click', () => {
                if (currentWizStep > 1) {
                    // Save current
                    const input = document.getElementById(`wiz-input-${currentWizStep}`);
                    if (input) wizAnswers[currentWizStep] = input.value;

                    currentWizStep--;
                    renderWizardStep(currentWizStep);
                }
            });
        }

        if (btnWizNext) {
            btnWizNext.addEventListener('click', async () => {
                const input = document.getElementById(`wiz-input-${currentWizStep}`);
                if (!input || !input.value.trim()) {
                    alert('ÂõûÁ≠î„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
                    return;
                }

                // Save current answer
                wizAnswers[currentWizStep] = input.value;

                // If not the last step, advance to next step
                if (currentWizStep < totalSteps) {
                    currentWizStep++;
                    renderWizardStep(currentWizStep);
                    return;
                }

                // Last step - generate AI response
                btnWizNext.disabled = true;
                btnWizNext.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> ÁîüÊàê‰∏≠...';

                const userPrompt = `
                ‰ª•‰∏ã„ÅÆ5„Å§„ÅÆÂõûÁ≠î„ÇíÂÖÉ„Å´„ÄÅÂéüÁî∞„É°„ÇΩ„ÉÉ„Éâ„ÅÆ„Äå4Ë¶≥ÁÇπ„Ç∑„Éº„Éà„Äç„ÄÅ„Äå„É°„Ç§„É≥ÁõÆÊ®ô„Äç„ÄÅ„Åù„Åó„Å¶ÁõÆÊ®ôÈÅîÊàê„Åæ„Åß„ÅÆ„Äå„Éû„Ç§„É´„Çπ„Éà„Éº„É≥Ôºà3Êó•Âæå„ÄÅ1ÈÄ±ÈñìÂæå„ÄÅ1„É∂ÊúàÂæå„ÄÅ3„É∂ÊúàÂæå„ÄÅÂçäÂπ¥Âæå„ÄÅ1Âπ¥ÂæåÔºâ„Äç„ÇíJSONÂΩ¢Âºè„ÅßÁîüÊàê„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
                ÂõûÁ≠î1(ÁõÆÊ®ô): ${wizAnswers[1]}
                ÂõûÁ≠î2(ÁêÜÁî±): ${wizAnswers[2]}
                ÂõûÁ≠î3(Ëá™ÂàÜÊúâÂΩ¢): ${wizAnswers[3]}
                ÂõûÁ≠î4(Ëá™ÂàÜÁÑ°ÂΩ¢): ${wizAnswers[4]}
                ÂõûÁ≠î5(Á§æ‰ºö‰ªñËÄÖ): ${wizAnswers[5]}
                
                ÈáçË¶ÅÔºöÂÖ∑‰ΩìÁöÑ„ÅßÊï∞ÂÄ§Âåñ„Åï„Çå„ÅüÁõÆÊ®ô„ÇíÁîüÊàê„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ„Éû„Ç§„É´„Çπ„Éà„Éº„É≥„ÅØÂÖ∑‰ΩìÁöÑ„Å™Ë°åÂãï„Å®Êï∞ÂÄ§ÁõÆÊ®ô„ÇíÂê´„ÇÅ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
                
                Âá∫Âäõ„Éï„Ç©„Éº„Éû„ÉÉ„ÉàJSON:
                {
                    "goal": "ÂÖ∑‰ΩìÁöÑ„ÅßÊ∏¨ÂÆöÂèØËÉΩ„Å™„É°„Ç§„É≥ÁõÆÊ®ôÔºà‰æãÔºö„Äá„Äá„ÇíÈÅîÊàê„Åô„ÇãÔºâ",
                    "deadline": "YYYY-MM-DDÂΩ¢ÂºèÔºà‰ªäÊó•„Åã„ÇâÂçäÂπ¥Âæå„Åè„Çâ„ÅÑ„ÇíÁõÆÂÆâ„Å´Ôºâ",
                    "selfTangible": "ÁßÅ„ÉªÊúâÂΩ¢ÔºöËá™ÂàÜ„ÅåÂæó„Çâ„Çå„ÇãÂÖ∑‰ΩìÁöÑ„Å™ÊàêÊûúÁâ©„ÇÑ„ÅäÈáë",
                    "selfIntangible": "ÁßÅ„ÉªÁÑ°ÂΩ¢ÔºöËá™ÂàÜ„ÅÆÂøÉ„ÇÑ„Çπ„Ç≠„É´„ÅÆÊàêÈï∑",
                    "societyTangible": "Á§æ‰ºö‰ªñËÄÖ„ÉªÊúâÂΩ¢Ôºö‰ªñËÄÖ„ÇÑÁµÑÁπî„Å´Êèê‰æõ„Åß„Åç„ÇãÂÖ∑‰ΩìÁöÑ„Å™ÊàêÊûú",
                    "societyIntangible": "Á§æ‰ºö‰ªñËÄÖ„ÉªÁÑ°ÂΩ¢Ôºö‰ªñËÄÖ„Å´‰∏é„Åà„ÇãÁõÆ„Å´Ë¶ã„Åà„Å™„ÅÑÂΩ±Èüø",
                    "milestones": {
                        "days3": "3Êó•ÂæåÔºöÊúÄÂàù„ÅÆ‰∏ÄÊ≠©„Å®„Åó„Å¶ÂÖ∑‰ΩìÁöÑ„Å´‰Ωï„Çí„Åô„Çã",
                        "week1": "1ÈÄ±ÈñìÂæåÔºöÊúÄÂàù„ÅÆÊàêÊûú„Å®„Åó„Å¶‰Ωï„ÇíÈÅîÊàê„Åô„Çã",
                        "month1": "1„É∂ÊúàÂæåÔºöÁøíÊÖ£Âåñ„ÅÆÁõÆÂÆâ„Å®„Åó„Å¶‰Ωï„Åå„Åß„Åç„Å¶„ÅÑ„Çã",
                        "month3": "3„É∂ÊúàÂæåÔºöÂõõÂçäÊúü„ÅÆÊàêÊûú„Å®„Åó„Å¶‰Ωï„ÇíÈÅîÊàê„Åô„Çã",
                        "month6": "ÂçäÂπ¥ÂæåÔºöÊäò„ÇäËøî„ÅóÂú∞ÁÇπ„Å®„Åó„Å¶‰Ωï„Åå„Åß„Åç„Å¶„ÅÑ„Çã",
                        "year1": "1Âπ¥ÂæåÔºöÊúÄÁµÇÁõÆÊ®ô„Å®„Åó„Å¶‰Ωï„ÇíÈÅîÊàê„Åó„Å¶„ÅÑ„Çã"
                    }
                }
            `;

                chrome.runtime.sendMessage({
                    type: 'generate-ai-response',
                    prompt: userPrompt
                }, (response) => {
                    btnWizNext.disabled = false;
                    btnWizNext.innerHTML = 'ÁîüÊàê„Åô„Çã <i class="fa-solid fa-wand-magic-sparkles"></i>';

                    if (chrome.runtime.lastError) {
                        console.error(chrome.runtime.lastError);
                        alert('„Ç®„É©„Éº: ' + chrome.runtime.lastError.message);
                        return;
                    }

                    if (response && response.success) {
                        try {
                            let data = response.data;
                            if (!data && response.raw) {
                                // Extract JSON if embedded in text
                                const jsonMatch = response.raw.match(/\{[\s\S]*\}/);
                                if (jsonMatch) {
                                    try { data = JSON.parse(jsonMatch[0]); } catch (e) { }
                                }
                            }

                            if (!data) {
                                alert('ÁîüÊàêÁµêÊûú„ÅÆËß£Êûê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ\n' + (response.raw || ''));
                                console.log(response.raw);
                                return;
                            }

                            // Apply to inputs
                            if (data.goal && goalInput) goalInput.value = data.goal;
                            if (data.deadline && deadlineInput) deadlineInput.value = data.deadline;
                            if (data.selfTangible && viewInputs.selfTangible) viewInputs.selfTangible.value = data.selfTangible;
                            if (data.selfIntangible && viewInputs.selfIntangible) viewInputs.selfIntangible.value = data.selfIntangible;
                            if (data.societyTangible && viewInputs.societyTangible) viewInputs.societyTangible.value = data.societyTangible;
                            if (data.societyIntangible && viewInputs.societyIntangible) viewInputs.societyIntangible.value = data.societyIntangible;

                            // Apply to Milestones
                            if (data.milestones) {
                                if (data.milestones.days3 && milestoneInputs.days3) milestoneInputs.days3.value = data.milestones.days3;
                                if (data.milestones.week1 && milestoneInputs.week1) milestoneInputs.week1.value = data.milestones.week1;
                                if (data.milestones.month1 && milestoneInputs.month1) milestoneInputs.month1.value = data.milestones.month1;
                                if (data.milestones.month3 && milestoneInputs.month3) milestoneInputs.month3.value = data.milestones.month3;
                                if (data.milestones.month6 && milestoneInputs.month6) milestoneInputs.month6.value = data.milestones.month6;
                                if (data.milestones.year1 && milestoneInputs.year1) milestoneInputs.year1.value = data.milestones.year1;
                            }

                            // Also save to appState
                            appState.goal = data.goal || '';
                            appState.deadline = data.deadline || '';
                            appState.fourViews = {
                                selfTangible: data.selfTangible || '',
                                selfIntangible: data.selfIntangible || '',
                                societyTangible: data.societyTangible || '',
                                societyIntangible: data.societyIntangible || ''
                            };
                            appState.milestones = data.milestones || {};
                            saveState();

                            // Clear draft
                            localStorage.removeItem('nld_wiz_draft');

                            wizardModal.classList.remove('open');
                            alert('üéâ ÁõÆÊ®ôË®≠ÂÆö„ÅåÁîüÊàê„Åï„Çå„Åæ„Åó„ÅüÔºÅ\n\nÂêÑÈ†ÖÁõÆ„ÇíÁ¢∫Ë™ç„Åó„Å¶„ÄÅÂøÖË¶Å„Å´Âøú„Åò„Å¶Á∑®ÈõÜ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ\n„Äå‰øùÂ≠ò„Äç„Éú„Çø„É≥„Åß‰øùÂ≠ò„Åß„Åç„Åæ„Åô„ÄÇ');

                        } catch (e) {
                            console.error(e);
                            alert('ÁîüÊàêÁµêÊûú„ÅÆËß£Êûê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ„ÇÇ„ÅÜ‰∏ÄÂ∫¶Ë©¶„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
                        }
                    } else {
                        alert('ÁîüÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ' + (response ? response.error : 'ÂøúÁ≠î„Åå„ÅÇ„Çä„Åæ„Åõ„Çì'));
                    }
                });
            });
        }


        // --- Mandala Logic ---
        const mandalaContainer = document.getElementById('mandala-grid');

        function renderMandala() {
            if (!mandalaContainer) return;
            // Ensure mandala array exists
            if (!appState.mandala || !Array.isArray(appState.mandala) || appState.mandala.length !== 9) {
                appState.mandala = Array(9).fill(null).map(() => Array(9).fill(''));
            }
            mandalaContainer.innerHTML = '';
            for (let bIndex = 0; bIndex < 9; bIndex++) {
                const blockDiv = document.createElement('div');
                blockDiv.className = 'mandala-block';
                // Add special class for center block
                if (bIndex === 4) blockDiv.classList.add('center-block');
                for (let cIndex = 0; cIndex < 9; cIndex++) {
                    const cellDiv = document.createElement('div');
                    cellDiv.className = 'mandala-cell';
                    const isBlockCenter = cIndex === 4;
                    const isCoreCenter = bIndex === 4 && cIndex === 4;

                    if (isCoreCenter) cellDiv.classList.add('core-center');
                    else if (isBlockCenter) cellDiv.classList.add('center-cell');

                    // Focus textarea when clicking the cell background (since textarea might be small)
                    cellDiv.addEventListener('click', (e) => {
                        if (e.target !== textArea) {
                            textArea.focus();
                        }
                    });

                    const textArea = document.createElement('textarea');
                    textArea.value = appState.mandala[bIndex][cIndex] || '';

                    const isOuterBlockCenter = isBlockCenter && bIndex !== 4;
                    if (isOuterBlockCenter) {
                        textArea.readOnly = true;
                        textArea.placeholder = "Ôºà‰∏≠Â§Æ„Åã„ÇâÂèçÊò†Ôºâ";
                    }

                    textArea.addEventListener('change', (e) => {
                        const newVal = e.target.value;
                        appState.mandala[bIndex][cIndex] = newVal;
                        if (bIndex === 4 && cIndex !== 4) {
                            appState.mandala[cIndex][4] = newVal;
                        }
                        saveState();
                        renderMandala();
                    });
                    cellDiv.appendChild(textArea);
                    blockDiv.appendChild(cellDiv);
                }
                mandalaContainer.appendChild(blockDiv);
            }
        }

        // --- Routine Matrix Logic ---
        const routineMatrix = document.getElementById('routine-matrix');
        const newRoutineInput = document.getElementById('new-routine-input');
        const addRoutineBtn = document.getElementById('add-routine-btn');

        // Helper to get array of dates for the matrix (last 13 days + today)
        function getMatrixDates() {
            const dates = [];
            const end = new Date();
            for (let i = 13; i >= 0; i--) {
                const d = new Date(end);
                d.setDate(d.getDate() - i);
                dates.push(d);
            }
            return dates;
        }

        function renderRoutineMatrix() {
            if (!routineMatrix) return;
            routineMatrix.innerHTML = '';
            const dates = getMatrixDates();

            // 1. Header Row
            const headerRow = document.createElement('tr');
            const cornerTh = document.createElement('th');
            cornerTh.className = 'routine-name-col';
            cornerTh.textContent = '„É´„Éº„ÉÜ„Ç£„É≥È†ÖÁõÆ';
            headerRow.appendChild(cornerTh);

            dates.forEach(d => {
                const th = document.createElement('th');
                const dateStr = d.toISOString().split('T')[0];
                const isToday = dateStr === new Date().toISOString().split('T')[0];
                if (isToday) th.classList.add('today-col');

                // Format: MM/DD
                th.textContent = `${d.getMonth() + 1}/${d.getDate()}`;
                headerRow.appendChild(th);
            });
            routineMatrix.appendChild(headerRow);

            // 2. Data Rows
            if (appState.routines.length === 0) {
                const emptyRow = document.createElement('tr');
                const td = document.createElement('td');
                td.colSpan = 15;
                td.textContent = '„É´„Éº„ÉÜ„Ç£„É≥„ÅåÁôªÈå≤„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ‰∏ãÈÉ®„ÅÆ„Éï„Ç©„Éº„É†„Åã„ÇâËøΩÂä†„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ';
                td.style.padding = '20px';
                td.style.color = 'var(--text-secondary)';
                emptyRow.appendChild(td);
                routineMatrix.appendChild(emptyRow);
                return;
            }

            let draggedRoutineIndex = null;

            appState.routines.forEach((routine, index) => {
                const tr = document.createElement('tr');
                tr.classList.add('routine-row');
                tr.draggable = true;
                tr.dataset.index = index;

                // Drag Events
                tr.addEventListener('dragstart', (e) => {
                    draggedRoutineIndex = index;
                    tr.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                    // Set drag image/data if needed
                });

                tr.addEventListener('dragend', () => {
                    tr.classList.remove('dragging');
                    document.querySelectorAll('.routine-row').forEach(row => {
                        row.classList.remove('drag-over-top', 'drag-over-bottom');
                    });
                    draggedRoutineIndex = null;
                });

                tr.addEventListener('dragover', (e) => {
                    e.preventDefault(); // allow drop
                    if (draggedRoutineIndex === null || draggedRoutineIndex === index) return;

                    const rect = tr.getBoundingClientRect();
                    const midY = rect.top + rect.height / 2;

                    tr.classList.remove('drag-over-top', 'drag-over-bottom');
                    if (e.clientY < midY) {
                        tr.classList.add('drag-over-top');
                    } else {
                        tr.classList.add('drag-over-bottom');
                    }
                });

                tr.addEventListener('dragleave', () => {
                    tr.classList.remove('drag-over-top', 'drag-over-bottom');
                });

                tr.addEventListener('drop', (e) => {
                    e.preventDefault();
                    if (draggedRoutineIndex === null || draggedRoutineIndex === index) return;

                    // Calculate drop position
                    const rect = tr.getBoundingClientRect();
                    const midY = rect.top + rect.height / 2;
                    let newIndex = index;

                    // If dropped on top half, insert before current index
                    // If dropped on bottom half, insert after current index
                    if (e.clientY >= midY) {
                        newIndex = index + 1; // Insert after
                    }

                    // Adjust newIndex because removing the item shifts indices
                    // If we move item from top (low index) to bottom (high index), 
                    // the target index shifts by -1 after removal.
                    // But array splice logic handles insertion.
                    // Let's use simple array move logic.

                    const items = [...appState.routines];
                    const [draggedItem] = items.splice(draggedRoutineIndex, 1);

                    // If we removed an item before the target, the target index shifts down
                    if (draggedRoutineIndex < index) {
                        if (e.clientY < midY) {
                            // Insert before current (which shifted down 1)
                            items.splice(index - 1, 0, draggedItem);
                        } else {
                            // Insert after current (which shifted down 1)
                            // originally index, became index-1. 
                            // Wait, let's use the visual target index logic.
                            // Simplified:
                            // Remove item first.
                            // If dropped ABOVE target (client Y < midY): insert at `index - (dragged < index ? 1 : 0)`
                            // If dropped BELOW target: insert at `index + (dragged < index ? 0 : 1)`
                            // Actually, let's just use the splice logic carefully.

                            let insertIndex = index;
                            if (e.clientY >= midY) insertIndex++;

                            // Since we already removed the item, if original index was less than insertIndex, decrease insertIndex
                            if (draggedRoutineIndex < insertIndex) insertIndex--;

                            items.splice(insertIndex, 0, draggedItem);
                        }
                    } else {
                        // dragged from below
                        if (e.clientY < midY) {
                            items.splice(index, 0, draggedItem);
                        } else {
                            items.splice(index + 1, 0, draggedItem);
                        }
                    }

                    appState.routines = items;
                    saveState();
                    renderRoutineMatrix();
                });


                // Name Cell with Delete
                // FIXED: Removed inserted block
                // const routineMatrix = document.getElementById('routine-matrix-body');

                function renderRoutineMatrix() {
                    if (!routineMatrix) return;
                    routineMatrix.innerHTML = '';

                    const dates = [];
                    for (let i = 6; i >= 0; i--) {
                        const d = new Date();
                        d.setDate(d.getDate() - i);
                        dates.push(d);
                    }
                }

                // Attach delete handler manually
                nameTd.querySelector('.fa-trash').addEventListener('click', (e) => {
                    e.stopPropagation();
                    // Prevent delete while dragging? Not strictly necessary but good UX
                    if (confirm(`„Äå${routine.text}„Äç„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü`)) {
                        appState.routines = appState.routines.filter(r => r.id !== routine.id);
                        saveState();
                        renderRoutineMatrix();
                    }
                });
                tr.appendChild(nameTd);

                // Checkbox Cells
                dates.forEach(d => {
                    const dateKey = d.toISOString().split('T')[0];
                    const td = document.createElement('td');
                    const isToday = dateKey === new Date().toISOString().split('T')[0];
                    if (isToday) td.classList.add('today-col');

                    const dailyLog = appState.logs[dateKey] || {};
                    const isChecked = !!dailyLog[routine.id];

                    const checkDiv = document.createElement('div');
                    checkDiv.className = `matrix - check ${isChecked ? 'checked' : ''} `;
                    checkDiv.innerHTML = '<i class="fa-solid fa-check"></i>';

                    checkDiv.addEventListener('click', () => {
                        const currentLog = appState.logs[dateKey] || {};
                        currentLog[routine.id] = !currentLog[routine.id];
                        appState.logs[dateKey] = currentLog;
                        saveState();
                        renderRoutineMatrix(); // Re-render to update UI (or just toggle class for perf)
                    });

                    td.appendChild(checkDiv);
                    tr.appendChild(td);
                });

                routineMatrix.appendChild(tr);
            });
        }

        if (addRoutineBtn && newRoutineInput) {
            addRoutineBtn.addEventListener('click', () => {
                const text = newRoutineInput.value.trim();
                if (text) {
                    appState.routines.push({ id: Date.now().toString(), text: text });
                    newRoutineInput.value = '';
                    saveState();
                    renderRoutineMatrix();
                }
            });
        }


        // --- Dashboard ---
        // --- Dashboard ---
        function updateDashboard() {
            // Safe update for Archived Dashboard Widgets
            const mainGoalEl = document.getElementById('dashboard-main-goal');
            if (mainGoalEl) mainGoalEl.textContent = appState.goal || 'ÁõÆÊ®ôÊú™Ë®≠ÂÆö';

            const deadlineEl = document.getElementById('dashboard-deadline');
            if (deadlineEl) deadlineEl.textContent = appState.deadline ? `ÊúüÊó•: ${appState.deadline} ` : '';

            // Today's Routine Stats
            const todoDoneEl = document.getElementById('today-routine-done');
            if (todoDoneEl) {
                const now = new Date();
                const dayKey = now.toISOString().split('T')[0];
                const todaysLog = appState.logs[dayKey] || {};
                const total = appState.routines.length;
                const done = appState.routines.filter(r => todaysLog[r.id]).length;

                todoDoneEl.textContent = done;
                if (document.getElementById('today-routine-total')) document.getElementById('today-routine-total').textContent = total;

                const percentage = total === 0 ? 0 : Math.round((done / total) * 100);

                const pb = document.querySelector('.progress-bar-fill');
                if (pb) pb.style.width = `${percentage}% `;
                const pt = document.querySelector('.progress-text');
                if (pt) pt.textContent = `${percentage}% ÈÅîÊàê`;
            }

            const kpItems = document.querySelectorAll('.kp-item');
            if (kpItems.length > 0) {
                const views = [
                    appState.fourViews.selfTangible, appState.fourViews.selfIntangible,
                    appState.fourViews.societyTangible, appState.fourViews.societyIntangible
                ];
                kpItems.forEach((item, index) => {
                    if (views[index] && views[index].length > 0) {
                        item.style.background = 'rgba(210, 153, 34, 0.2)';
                        const icon = item.querySelector('i');
                        if (icon) icon.style.opacity = '1';
                    } else {
                        item.style.background = 'rgba(255, 255, 255, 0.05)';
                        const icon = item.querySelector('i');
                        if (icon) icon.style.opacity = '0.5';
                    }
                });
            }
        }

        // --- Config Moved to Top ---


        const journalElements = {
            date: document.getElementById('journal-date'),
            title: document.getElementById('journal-title'), // Keeping for AI even if hidden
            tags: document.getElementById('journal-tags'),
            declaration: document.getElementById('journal-declaration'),
            content: document.getElementById('journal-textarea'), // Thoughts/Free
            calendar: document.getElementById('journal-calendar'),
            todo: document.getElementById('journal-todo'),
            activity: document.getElementById('journal-activity'),
            redo: document.getElementById('journal-redo'), // New
            confidence: document.getElementById('journal-confidence'), // New
            scores: {
                heart: document.getElementById('score-heart'),
                skill: document.getElementById('score-skill'),
                body: document.getElementById('score-body'),
                life: document.getElementById('score-life')
            },
            btnSchedule: document.getElementById('btn-get-schedule'),
            btnHistory: document.getElementById('btn-get-history'),
            btnTempSave: document.getElementById('btn-temp-save'),
            btnSave: document.getElementById('btn-save-sync'),
            btnAiFormat: document.getElementById('btn-ai-format'),
            status: document.getElementById('journal-status'),
            prevDate: document.getElementById('prev-date'),
            nextDate: document.getElementById('next-date')
        };

        const habitElements = {
            wakeup: document.getElementById('habit-wakeup'),
            bedtime: document.getElementById('habit-bedtime'),

            englishContentId: 'habit-english-content',
            englishTime: document.getElementById('habit-english-time'),
            muscleMenuId: 'habit-muscle-menu',
            muscleDetail: document.getElementById('habit-muscle-detail'),
            joggingDist: document.getElementById('habit-jogging-dist'),
            joggingTime: document.getElementById('habit-jogging-time'),
            stretchCheck: document.getElementById('habit-stretch-check'),
            stretchLabel: document.getElementById('habit-stretch-label'),
            socialMenuId: 'habit-social-menu'
        };

        let currentJournalDate = new Date();

        // --- HABIT HELPERS ---
        // --- Rest Mode Helpers ---
        function setRestMode(habitId, isResting) {
            const card = document.getElementById(`card - ${habitId} `);
            if (!card) return;

            if (isResting) {
                card.classList.add('resting');
            } else {
                card.classList.remove('resting');
            }

            const btn = card.querySelector(`.rest - btn[data - habit="${habitId}"]`);
            if (btn) {
                if (isResting) btn.classList.add('active');
                else btn.classList.remove('active');
            }
        }

        function initRestButtons() {
            document.querySelectorAll('.rest-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const habitId = btn.dataset.habit;
                    const card = document.getElementById(`card - ${habitId} `);
                    if (!card) return;

                    const isResting = !card.classList.contains('resting');
                    setRestMode(habitId, isResting);
                });
            });
        }

        // --- Slider Logic ---
        // --- Slider Logic ---
        function updateSliderDisplay(input) {
            const displayId = input.id.replace('habit-', 'display-');
            const display = document.getElementById(displayId);
            if (display) {
                const val = parseFloat(input.value);
                if (input.step === '0.1') {
                    display.textContent = val.toFixed(1);
                } else {
                    display.textContent = val;
                }
            }

            // Update Progress Background
            const min = parseFloat(input.min) || 0;
            const max = parseFloat(input.max) || 100;
            const val = parseFloat(input.value) || 0;
            const percentage = ((val - min) / (max - min)) * 100;
            // --accent-color: #ffd700; --border-color: rgba(255, 255, 255, 0.1);
            // We use JS to set the linear-gradient because we can't easily do it with pure CSS for range inputs cross-browser
            // Assuming variable names. We hardcode gold for now or read property?
            // Better to use var(--accent-color) but in linear-gradient string we need actual color or var() syntax.
            // var(--accent-color) works inside linear-gradient in modern browsers.
            input.style.background = `linear - gradient(to right, var(--accent - color) ${percentage}%, var(--border - color) ${percentage}%)`;
        }

        function initSliders() {
            document.querySelectorAll('.habit-slider').forEach(input => {
                // Init display
                updateSliderDisplay(input);

                // Input event
                input.addEventListener('input', () => updateSliderDisplay(input));
            });

            document.querySelectorAll('.slider-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const targetId = btn.dataset.target;
                    const step = parseFloat(btn.dataset.step);
                    const input = document.getElementById(targetId);
                    if (input) {
                        let current = parseFloat(input.value);
                        if (btn.classList.contains('plus')) {
                            current += step;
                        } else {
                            current -= step;
                        }
                        // Clamp
                        if (current < parseFloat(input.min)) current = parseFloat(input.min);
                        if (current > parseFloat(input.max)) current = parseFloat(input.max);

                        input.value = current;
                        // Fire input event manually so display updates
                        updateSliderDisplay(input);
                    }
                });
            });
        }

        function setupChipUI(containerId, savedValue, onChange) {
            const container = document.getElementById(containerId);
            if (!container) return;
            const chips = container.querySelectorAll('.chip');
            const selectedValues = (savedValue || '').split(',').map(s => s.trim());
            chips.forEach(chip => {
                if (selectedValues.includes(chip.getAttribute('data-value'))) chip.classList.add('active');
                else chip.classList.remove('active');
                chip.onclick = () => {
                    chip.classList.toggle('active');
                    if (onChange) onChange();
                };
            });
        }

        function getChipValues(containerId) {
            const container = document.getElementById(containerId);
            if (!container) return '';
            const activeChips = container.querySelectorAll('.chip.active');
            return Array.from(activeChips).map(c => c.getAttribute('data-value')).join(',');
        }

        function updateMuscleDetails(initialData) {
            const container = document.getElementById('habit-muscle-menu');
            const detailContainer = document.getElementById('muscle-details-container');
            if (!container || !detailContainer) return;

            const activeChips = Array.from(container.querySelectorAll('.chip.active'));
            const activeValues = activeChips.map(c => c.getAttribute('data-value'));

            const currentData = initialData || {};
            if (!initialData) {
                Array.from(detailContainer.children).forEach(row => {
                    const w = row.querySelector('.weight-select')?.value;
                    const s = row.querySelector('.sets-select')?.value;
                    if (row.dataset.name) currentData[row.dataset.name] = { w, s };
                });
            }

            detailContainer.innerHTML = '';

            activeValues.forEach(val => {
                if (val === '„Åù„ÅÆ‰ªñ') return;

                const row = document.createElement('div');
                row.className = 'muscle-detail-row';
                row.dataset.name = val;

                const nameDiv = document.createElement('div');
                nameDiv.className = 'muscle-detail-name';
                nameDiv.textContent = val;

                const wSel = document.createElement('select');
                wSel.className = 'muscle-detail-select weight-select';
                const bw = document.createElement('option'); bw.value = 'Ëá™Èáç'; bw.textContent = 'Ëá™Èáç';
                wSel.appendChild(bw);
                for (let i = 10; i <= 140; i += 2.5) {
                    const opt = document.createElement('option');
                    opt.value = i + 'kg'; opt.textContent = i + 'kg';
                    if (opt.value === (currentData[val]?.w || '60kg')) opt.selected = true;
                    wSel.appendChild(opt);
                }
                if (currentData[val]?.w === 'Ëá™Èáç') wSel.value = 'Ëá™Èáç';

                const sSel = document.createElement('select');
                sSel.className = 'muscle-detail-select sets-select';
                for (let i = 1; i <= 10; i++) {
                    const opt = document.createElement('option');
                    opt.value = i + 'set'; opt.textContent = i + ' set';
                    if (opt.value === (currentData[val]?.s || '3set')) opt.selected = true;
                    sSel.appendChild(opt);
                }

                row.appendChild(nameDiv);
                row.appendChild(wSel);
                row.appendChild(sSel);
                detailContainer.appendChild(row);
            });
        }

        // --- English Learning Details (similar to muscle) ---
        function updateEnglishDetails(initialData) {
            const container = document.getElementById('habit-english-content');
            const detailContainer = document.getElementById('english-details-container');
            if (!container || !detailContainer) return;

            const activeChips = Array.from(container.querySelectorAll('.chip.active'));
            const activeValues = activeChips.map(c => c.getAttribute('data-value'));

            // Collect current data before re-rendering
            const currentData = initialData || {};
            if (!initialData) {
                Array.from(detailContainer.children).forEach(row => {
                    const time = row.querySelector('.english-time-select')?.value;
                    const note = row.querySelector('.english-note-input')?.value;
                    if (row.dataset.name) currentData[row.dataset.name] = { time, note };
                });
            }

            detailContainer.innerHTML = '';

            activeValues.forEach(val => {
                const row = document.createElement('div');
                row.className = 'english-detail-row';
                row.dataset.name = val;

                const nameDiv = document.createElement('div');
                nameDiv.className = 'english-detail-name';
                nameDiv.textContent = val;

                // Time selector (10min ~ 120min)
                const timeSel = document.createElement('select');
                timeSel.className = 'english-detail-select english-time-select';
                const times = [10, 15, 20, 30, 45, 60, 90, 120];
                times.forEach(t => {
                    const opt = document.createElement('option');
                    opt.value = t + 'ÂàÜ';
                    opt.textContent = t + 'ÂàÜ';
                    if (opt.value === (currentData[val]?.time || '30ÂàÜ')) opt.selected = true;
                    timeSel.appendChild(opt);
                });

                // Note input
                const noteInput = document.createElement('input');
                noteInput.type = 'text';
                noteInput.className = 'english-note-input';
                noteInput.placeholder = '„É°„É¢';
                noteInput.value = currentData[val]?.note || '';

                row.appendChild(nameDiv);
                row.appendChild(timeSel);
                row.appendChild(noteInput);
                detailContainer.appendChild(row);
            });
        }

        // --- LOAD DATA LOGIC ---
        const loadDiaryData = (dateStr) => {
            currentJournalDate = new Date(dateStr);
            console.log('Loading data for:', dateStr);
            const log = appState.logs[dateStr] || {};

            // Journal
            if (journalElements.title) journalElements.title.value = log.title || '';
            if (journalElements.tags) journalElements.tags.value = log.tags || '';
            if (journalElements.content) journalElements.content.value = log.content || '';
            if (journalElements.declaration) journalElements.declaration.value = log.declaration || '';
            if (journalElements.calendar) journalElements.calendar.value = log.calendar || '';
            if (journalElements.todo) journalElements.todo.value = log.tasks || '';
            if (journalElements.activity) journalElements.activity.value = log.activity || '';
            if (journalElements.redo) journalElements.redo.value = log.redo || '';
            if (journalElements.confidence) journalElements.confidence.value = log.confidence || '';

            // Scores
            if (log.scores) {
                try {
                    const s = typeof log.scores === 'string' ? JSON.parse(log.scores) : log.scores;
                    if (journalElements.scores.heart) journalElements.scores.heart.value = s.heart || '5';
                    if (journalElements.scores.skill) journalElements.scores.skill.value = s.skill || '5';
                    if (journalElements.scores.body) journalElements.scores.body.value = s.body || '5';
                    if (journalElements.scores.life) journalElements.scores.life.value = s.life || '5';
                } catch (e) { }
            } else {
                if (journalElements.scores.heart) journalElements.scores.heart.value = '5';
                if (journalElements.scores.skill) journalElements.scores.skill.value = '5';
                if (journalElements.scores.body) journalElements.scores.body.value = '5';
                if (journalElements.scores.life) journalElements.scores.life.value = '5';
            }

            // Habits
            const h = habitElements;
            const sh = log.habits || {};

            // Sleep
            const isSleepRest = sh.wakeup === '„Åä‰ºë„Åø';
            setRestMode('sleep', isSleepRest);
            if (!isSleepRest) {
                if (h.wakeup) h.wakeup.value = sh.wakeup || '';
                if (h.bedtime) h.bedtime.value = sh.bedtime || '';
            }

            // English
            const isEnglishRest = sh.englishContent === '„Åä‰ºë„Åø';
            setRestMode('english', isEnglishRest);

            setupChipUI(h.englishContentId, isEnglishRest ? null : sh.englishContent, updateEnglishDetails);

            let englishDetailData = {};
            if (!isEnglishRest && sh.englishDetail) {
                sh.englishDetail.split('\n').forEach(line => {
                    const match = line.match(/^(.+?): (\d+ÂàÜ)(?: - (.*))?$/);
                    if (match) {
                        englishDetailData[match[1]] = { time: match[2], note: match[3] || '' };
                    }
                });
            }
            updateEnglishDetails(englishDetailData);

            const englishMemo = document.getElementById('habit-english-memo');
            if (englishMemo) englishMemo.value = (!isEnglishRest && sh.englishMemo) ? sh.englishMemo : '';

            // Muscle
            const isMuscleRest = sh.muscleMenu === '„Åä‰ºë„Åø';
            setRestMode('muscle', isMuscleRest);

            let muscleDataText = (!isMuscleRest && sh.muscleDetail) ? sh.muscleDetail : '';
            let memoText = '';
            if (muscleDataText.includes('--- „É°„É¢ ---')) {
                const parts = muscleDataText.split('--- „É°„É¢ ---');
                muscleDataText = parts[0].trim();
                memoText = parts[1].trim();
            } else if (!muscleDataText.includes(':') && muscleDataText.length > 0) {
                memoText = muscleDataText;
                muscleDataText = '';
            }
            const initialMuscleData = {};
            muscleDataText.split('\n').forEach(line => {
                const p = line.split(':');
                if (p.length >= 2) {
                    const vals = p[1].trim().split(' ');
                    initialMuscleData[p[0].trim()] = { w: vals[0], s: vals[1] || '3set' };
                }
            });
            setupChipUI(h.muscleMenuId, isMuscleRest ? null : sh.muscleMenu, () => updateMuscleDetails(null));
            updateMuscleDetails(initialMuscleData);

            if (h.muscleDetail) h.muscleDetail.value = memoText;

            // Jogging
            const isJogRest = sh.joggingDist === '„Åä‰ºë„Åø';
            setRestMode('jogging', isJogRest);
            if (!isJogRest) {
                if (h.joggingDist) {
                    h.joggingDist.value = sh.joggingDist || '0';
                    updateSliderDisplay(h.joggingDist);
                }
                if (h.joggingTime) {
                    h.joggingTime.value = sh.joggingTime || '0';
                    updateSliderDisplay(h.joggingTime);
                }
            } else {
                if (h.joggingDist) {
                    h.joggingDist.value = '0';
                    updateSliderDisplay(h.joggingDist);
                }
                if (h.joggingTime) {
                    h.joggingTime.value = '0';
                    updateSliderDisplay(h.joggingTime);
                }
            }

            // Social
            const isSocialRest = sh.socialMenu === '„Åä‰ºë„Åø';
            setRestMode('social', isSocialRest);
            setupChipUI(h.socialMenuId, isSocialRest ? null : sh.socialMenu);

            // Stretch
            const isStretchRest = sh.stretchCheck === '„Åä‰ºë„Åø';
            setRestMode('stretch', isStretchRest);
            if (h.stretchCheck) {
                if (isStretchRest) {
                    h.stretchCheck.checked = false;
                    if (h.stretchLabel) h.stretchLabel.textContent = '„Åä‰ºë„Åø';
                } else {
                    h.stretchCheck.checked = !!sh.stretchCheck;
                    if (h.stretchLabel) h.stretchLabel.textContent = h.stretchCheck.checked ? 'ÂÆüÊñΩÊ∏à„Åø' : 'Êú™ÂÆüÊñΩ';
                }
            }

            // Render Routine Matrix for selected date
            renderRoutineMatrix(dateStr);
        };

        const updateJournalDateDisplay = () => {
            if (journalElements.date) {
                const y = currentJournalDate.getFullYear();
                const m = String(currentJournalDate.getMonth() + 1).padStart(2, '0');
                const d = String(currentJournalDate.getDate()).padStart(2, '0');
                const daStr = `${y} -${m} -${d} `;
                if (journalElements.date.value !== daStr) journalElements.date.value = daStr;
                loadDiaryData(daStr);
            }
        };

        // Initialize date
        updateJournalDateDisplay();

        if (journalElements.date) {
            journalElements.date.addEventListener('change', (e) => {
                loadDiaryData(e.target.value);
            });
        }
        if (journalElements.prevDate) {
            journalElements.prevDate.addEventListener('click', () => {
                currentJournalDate.setDate(currentJournalDate.getDate() - 1);
                updateJournalDateDisplay();
            });
        }
        if (journalElements.nextDate) {
            journalElements.nextDate.addEventListener('click', () => {
                currentJournalDate.setDate(currentJournalDate.getDate() + 1);
                updateJournalDateDisplay();
            });
        }

        const updateJournalStatus = (msg, isError = false) => {
            if (!journalElements.status) return;
            journalElements.status.textContent = msg;
            journalElements.status.style.color = isError ? '#ff6b6b' : 'var(--accent-gold)';
        };

        const checkExtensionEnvironment = () => {
            if (typeof chrome === 'undefined' || !chrome.runtime) {
                updateJournalStatus('Êã°ÂºµÊ©üËÉΩÁí∞Â¢É„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì', true);
                alert('„Åì„ÅÆÊ©üËÉΩ„ÅØChromeÊã°ÂºµÊ©üËÉΩ„Å®„Åó„Å¶ÂÆüË°å‰∏≠„ÅÆ„Åø‰ΩøÁî®„Åß„Åç„Åæ„Åô„ÄÇ');
                return false;
            }
            return true;
        };

        if (journalElements.btnSchedule) {
            journalElements.btnSchedule.addEventListener('click', () => {
                if (!checkExtensionEnvironment()) return;
                const status = journalElements.status;
                const targetDate = journalElements.date ? journalElements.date.value : new Date().toISOString().split('T')[0];

                if (status) {
                    status.textContent = '‰∫àÂÆöÂèñÂæó‰∏≠...';
                    status.style.color = 'var(--accent-gold)';
                }

                chrome.runtime.sendMessage({ type: 'get-schedule', date: targetDate }, (res) => {
                    if (res && res.success) {
                        let hasData = false;
                        if (res.calendar && res.calendar.length > 0) {
                            if (journalElements.calendar) journalElements.calendar.value = res.calendar.join('\n');
                            hasData = true;
                        } else {
                            if (journalElements.calendar) journalElements.calendar.value = '(‰∫àÂÆö„Å™„Åó)';
                        }

                        if (res.tasks && res.tasks.length > 0) {
                            const t = journalElements.todo ? journalElements.todo.value : '';
                            if (journalElements.todo) journalElements.todo.value = (t ? t + '\n' : '') + res.tasks.join('\n');
                            hasData = true;
                        }

                        if (status) status.textContent = hasData ? '‰∫àÂÆöÂèñÂæóÂÆå‰∫Ü' : '‰∫àÂÆö„Å™„Åó';
                    } else {
                        console.error("Schedule Error:", res);
                        if (status) {
                            status.textContent = 'ÂèñÂæóÂ§±Êïó';
                            status.style.color = '#ff6b6b';
                        }
                        alert('‰∫àÂÆö„ÅÆÂèñÂæó„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ\n‰ª•‰∏ã„ÅÆÂéüÂõ†„ÅåËÄÉ„Åà„Çâ„Çå„Åæ„Åô:\n1. GAS„Éá„Éó„É≠„Ç§URL„ÅåÂè§„ÅÑ (ÂÜç„Éá„Éó„É≠„Ç§„Åó„ÄÅÊñ∞URL„ÇíË≤º„Çä‰ªò„Åë„Å¶„Åè„Å†„Åï„ÅÑ)\n2. Ê®©ÈôêË®≠ÂÆö„Éü„Çπ (ÂÖ®Âì°/Anyone„Å´„Å™„Å£„Å¶„ÅÑ„Å™„ÅÑ)\n\n„Ç®„É©„ÉºË©≥Á¥∞: ' + (res?.error || '‰∏çÊòé'));
                    }
                });
            });
        }

        if (journalElements.btnHistory) {
            journalElements.btnHistory.addEventListener('click', async () => {
                console.log('History Button Clicked');

                // Ê®©Èôê„Å™„Å©„ÅÆÁí∞Â¢É„ÉÅ„Çß„ÉÉ„ÇØ
                if (!chrome.history) {
                    alert('„Ç®„É©„Éº: „Åì„ÅÆÁí∞Â¢É„Åß„ÅØÂ±•Ê≠¥APIÔºàchrome.historyÔºâ„Åå‰Ωø„Åà„Åæ„Åõ„Çì„ÄÇmanifest.json„ÅÆÊ®©Èôê„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
                    return;
                }

                const status = journalElements.status;
                if (status) status.textContent = 'Â±•Ê≠¥ÂèñÂæó‰∏≠...';

                try {
                    // „Éá„Éê„ÉÉ„Ç∞Áî®: Ê§úÁ¥¢Êù°‰ª∂„ÇíÊ•µÈôê„Åæ„ÅßÁ∑©„ÇÅ„ÇãÔºàÁõ¥Ëøë„ÅÆÈ†ÖÁõÆ„ÇíÁÑ°Êù°‰ª∂„ÅßÂèñÂæóÔºâ
                    console.log('Searching history...');
                    const historyItems = await chrome.history.search({
                        text: '', // ÂÖ®„Å¶
                        maxResults: 100 // „Å®„Çä„ÅÇ„Åà„Åö100‰ª∂
                    });

                    console.log('History Items Found:', historyItems.length);

                    if (!historyItems || historyItems.length === 0) {
                        alert('Â±•Ê≠¥„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„ÅüÔºà0‰ª∂Ôºâ„ÄÇ„Éñ„É©„Ç¶„Ç∂„ÅÆË®≠ÂÆö„ÅßÂ±•Ê≠¥‰øùÂ≠ò„ÅåÁÑ°Âäπ„Å´„Å™„Å£„Å¶„ÅÑ„Åæ„Åõ„Çì„ÅãÔºü');
                        if (status) status.textContent = 'Â±•Ê≠¥„Å™„Åó';
                        return;
                    }

                    // Êó•‰ªò„Éï„Ç£„É´„Çø„É™„É≥„Ç∞Ôºà‰ªäÊó•„ÅÆ„ÇÇ„ÅÆ„Å†„ÅëÊäΩÂá∫Ôºâ
                    const targetDateStart = new Date(currentJournalDate);
                    targetDateStart.setHours(0, 0, 0, 0);
                    const targetDateEnd = new Date(currentJournalDate);
                    targetDateEnd.setHours(23, 59, 59, 999);

                    console.log('Filtering for date:', targetDateStart.toLocaleDateString());

                    const todaysItems = historyItems.filter(item => {
                        return item.lastVisitTime >= targetDateStart.getTime() &&
                            item.lastVisitTime <= targetDateEnd.getTime();
                    });

                    console.log('Items for today:', todaysItems.length);

                    if (todaysItems.length === 0) {
                        if (journalElements.activity) journalElements.activity.value = '(Êú¨Êó•„ÅÆÂ±•Ê≠¥„Å™„Åó)';
                        if (status) status.textContent = 'Êú¨Êó•„ÅÆÂ±•Ê≠¥„Å™„Åó';
                        return;
                    }

                    // Êï¥ÂΩ¢„Åó„Å¶Ë°®Á§∫
                    todaysItems.sort((a, b) => a.lastVisitTime - b.lastVisitTime); // Âè§„ÅÑÈ†Ü

                    const lines = todaysItems.map(item => {
                        const d = new Date(item.lastVisitTime);
                        const timeStr = d.toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit' });
                        return `${timeStr} ${item.title || 'No Title'} `;
                    });

                    // ÈáçË§áÊéíÈô§„Åó„Å¶ÁµêÂêà
                    const uniqueLines = [...new Set(lines)];

                    if (journalElements.activity) {
                        journalElements.activity.value = uniqueLines.join('\n');
                    }

                    if (status) status.textContent = `ÂèñÂæóÂÆå‰∫Ü(${uniqueLines.length}‰ª∂)`;

                } catch (err) {
                    console.error('History API Error:', err);
                    alert('Â±•Ê≠¥ÂèñÂæó‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü:\n' + err.message);
                }
            });
        }

        // Temp Save (Local only)
        if (journalElements.btnTempSave) {
            journalElements.btnTempSave.addEventListener('click', () => {
                const data = {
                    date: journalElements.date.value,
                    title: journalElements.title ? journalElements.title.value : '',
                    tags: journalElements.tags ? journalElements.tags.value : '',
                    declaration: journalElements.declaration ? journalElements.declaration.value : '',
                    content: journalElements.content.value,
                    redo: journalElements.redo ? journalElements.redo.value : '',
                    confidence: journalElements.confidence ? journalElements.confidence.value : '',
                    calendar: journalElements.calendar.value,
                    todo: journalElements.todo.value,
                    activity: journalElements.activity.value,
                    scores: {
                        heart: journalElements.scores.heart.value,
                        skill: journalElements.scores.skill.value,
                        body: journalElements.scores.body.value,
                        life: journalElements.scores.life.value
                    }
                };
                localStorage.setItem('temp_journal_autosave', JSON.stringify(data));
                updateJournalStatus('‰∏ÄÊôÇ‰øùÂ≠ò„Åó„Åæ„Åó„Åü');
            });
        }

        // AI Format Button
        if (journalElements.btnAiFormat) {
            journalElements.btnAiFormat.addEventListener('click', async () => {
                if (!checkExtensionEnvironment()) return;
                // Get content from everywhere
                const rawContent = `
                „ÄêÊúù„ÅÆÂÆ£Ë®Ä„Äë: ${journalElements.declaration.value}
                „Äê‰∫àÂÆö„Äë: ${journalElements.calendar.value}
                „Äê„ÇÑ„Çã„Åπ„Åç„Åì„Å®„Äë: ${journalElements.todo.value}
                „ÄêÊ¥ªÂãïÂ±•Ê≠¥„Äë: ${journalElements.activity.value}
                „ÄêÊîπÂñÑÁÇπ„Éª„ÇÑ„ÇäÁõ¥„Åó„Äë: ${journalElements.redo ? journalElements.redo.value : ''}
                „ÄêËâØ„Åã„Å£„Åü„Åì„Å®„ÉªËá™‰ø°„Äë: ${journalElements.confidence ? journalElements.confidence.value : ''}
                „ÄêÊÑüÊÉ≥„ÉªËá™Áî±Ë®òËø∞„Äë: ${journalElements.content.value}
            `;

                if (!rawContent.trim()) { alert('ÂÜÖÂÆπ„ÅåÁ©∫„Åß„Åô'); return; }

                updateJournalStatus('AIÊï¥ÂΩ¢‰∏≠...');

                let customPrompt = '';
                if (chrome.storage) {
                    const result = await chrome.storage.local.get(CONFIG_KEY);
                    const config = result[CONFIG_KEY] || {};
                    customPrompt = config.customPrompt || '';
                }

                chrome.runtime.sendMessage({
                    type: 'format-text',
                    text: rawContent,
                    userPrompt: customPrompt || '‰ª•‰∏ã„ÅÆÊó•Ë®ò„ÉªÊ¥ªÂãïË®òÈå≤„Çí„ÄÅË™≠„Åø„ÇÑ„Åô„ÅÑÊó•Ë™åÂΩ¢ÂºèÔºàMarkdownÔºâ„Å´Êï¥ÂΩ¢„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ„Çø„Ç§„Éà„É´„ÇÑ„Çø„Ç∞„ÇÇÊèêÊ°à„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ'
                }, (res) => {
                    if (res && res.success) {
                        if (res.title && journalElements.title) journalElements.title.value = res.title;
                        if (res.tags && journalElements.tags) journalElements.tags.value = res.tags;

                        // Put result in main textarea? Or keep split?
                        // AI formatting usually merges everything. Let's ask user or just put in main content for now.
                        // But here we might want to keep the structured inputs as is, and just output a summary?
                        // The prompt asks to format as "Text". 
                        // Let's put the formatted text into the "Free" area for now, or alert it?
                        // No, usually it replaces the content.
                        if (res.content) {
                            if (confirm('Êï¥ÂΩ¢ÁµêÊûú„Çí„ÄåËá™Áî±Ë®òËø∞„ÄçÊ¨Ñ„Å´‰∏äÊõ∏„Åç„Åó„Åæ„Åô„ÅãÔºü\nÔºàÂÖÉ„ÅÆÂÖ•ÂäõÂÜÖÂÆπ„ÅØ‰øùÊåÅ„Åï„Çå„Åæ„Åô„Åå„ÄÅAIÁµêÊûú„ÅØ„Åì„ÅÆÊ¨Ñ„Å´Áµ±Âêà„Åï„Çå„Åæ„ÅôÔºâ')) {
                                journalElements.content.value = res.content;
                            }
                        }

                        updateJournalStatus('AIÊï¥ÂΩ¢ÂÆå‰∫ÜÔºÅ');
                    } else {
                        updateJournalStatus('AIÊï¥ÂΩ¢Â§±Êïó', true);
                        alert('AIÊï¥ÂΩ¢Â§±Êïó: ' + (res?.error || '‰∏çÊòé'));
                    }
                });
            });
        }

        if (journalElements.btnSave) {
            journalElements.btnSave.addEventListener('click', () => {
                if (!checkExtensionEnvironment()) return;

                // 1. Sync CURRENT Habit UI to State (so user doesn't need to press "Save Habits" separately)
                const dateKey = journalElements.date ? journalElements.date.value : new Date().toISOString().split('T')[0];
                let currentLog = appState.logs[dateKey] || {};

                // Re-fetch elements directly to ensure freshness and avoid caching issues
                const hEl = {
                    wakeup: document.getElementById('habit-wakeup'),
                    bedtime: document.getElementById('habit-bedtime'),
                    englishContentId: 'habit-english-content',
                    englishTime: document.getElementById('habit-english-time'),
                    muscleMenuId: 'habit-muscle-menu',
                    muscleDetail: document.getElementById('habit-muscle-detail'),
                    joggingDist: document.getElementById('habit-jogging-dist'),
                    joggingTime: document.getElementById('habit-jogging-time'),
                    stretchCheck: document.getElementById('habit-stretch-check'),
                    socialMenuId: 'habit-social-menu'
                };

                if (hEl) {
                    // Collect muscle details
                    let genText = '';
                    const detailContainer = document.getElementById('muscle-details-container');
                    if (detailContainer) {
                        detailContainer.querySelectorAll('.muscle-detail-row').forEach(row => {
                            const w = row.querySelector('.weight-select')?.value || '';
                            const s = row.querySelector('.sets-select')?.value || '';
                            if (row.dataset.name) genText += `${row.dataset.name}: ${w} ${s} \n`;
                        });
                    }
                    const memo = hEl.muscleDetail?.value || '';
                    const finalDetail = (genText.trim() + (memo ? `\n-- - „É°„É¢-- -\n${memo} ` : '')).trim();

                    // Collect English details
                    let englishDetailText = '';
                    const englishDetailContainer = document.getElementById('english-details-container');
                    if (englishDetailContainer) {
                        englishDetailContainer.querySelectorAll('.english-detail-row').forEach(row => {
                            const time = row.querySelector('.english-time-select')?.value || '';
                            const note = row.querySelector('.english-note-input')?.value || '';
                            if (row.dataset.name) {
                                englishDetailText += `${row.dataset.name}: ${time}${note ? ' - ' + note : ''} \n`;
                            }
                        });
                    }
                    const englishMemoEl = document.getElementById('habit-english-memo');

                    const getRestVal = (id, val) => document.getElementById(`card - ${id} `)?.classList.contains('resting') ? '„Åä‰ºë„Åø' : val;
                    const isRest = (id) => document.getElementById(`card - ${id} `)?.classList.contains('resting');

                    currentLog.habits = {
                        wakeup: getRestVal('sleep', hEl.wakeup?.value || ''),
                        bedtime: getRestVal('sleep', hEl.bedtime?.value || ''),
                        englishContent: getRestVal('english', getChipValues(hEl.englishContentId)),
                        englishDetail: isRest('english') ? '' : englishDetailText.trim(),
                        englishMemo: isRest('english') ? '' : (englishMemoEl?.value || ''),
                        muscleMenu: getRestVal('muscle', getChipValues(hEl.muscleMenuId)),
                        muscleDetail: isRest('muscle') ? '' : finalDetail,
                        joggingDist: getRestVal('jogging', hEl.joggingDist?.value || ''),
                        joggingTime: isRest('jogging') ? '' : (hEl.joggingTime?.value || ''),
                        stretchCheck: getRestVal('stretch', hEl.stretchCheck?.checked || false),
                        socialMenu: getRestVal('social', getChipValues(hEl.socialMenuId))
                    };
                    appState.logs[dateKey] = currentLog;
                    saveState();
                }

                // 2. Calculate Done Routines (Matrix)
                const doneRoutines = appState.routines
                    .filter(r => currentLog[r.id])
                    .map(r => r.text)
                    .join(', ');

                // 3. Generate Full Routine Text
                const h = currentLog.habits || {};
                let habitItems = [];
                if (h.wakeup || h.bedtime) habitItems.push(`[Áù°Áú†] Ëµ∑Â∫ä:${h.wakeup || '-'} / Â∞±ÂØù:${h.bedtime || '-'}`);
                if (h.englishContent) habitItems.push(`[Ëã±Ë™û] ${h.englishContent} (${h.englishTime || '-'})`);
                if (h.muscleMenu) habitItems.push(`[Á≠ã„Éà„É¨] ${h.muscleMenu}\n${h.muscleDetail || ''}`);
                if (h.joggingDist) habitItems.push(`[Jog] ${h.joggingDist}km (${h.joggingTime || '-'}ÂàÜ)`);
                if (h.stretchCheck) habitItems.push(`[„Çπ„Éà„É¨„ÉÉ„ÉÅ] ÂÆüÊñΩ`);
                if (h.socialMenu) habitItems.push(`[Áô∫‰ø°] ${h.socialMenu}`);

                const fullRoutineLog = [doneRoutines, ...habitItems].filter(s => s).join('\n');

                const scoresJson = JSON.stringify({
                    heart: journalElements.scores.heart.value,
                    skill: journalElements.scores.skill.value,
                    body: journalElements.scores.body.value,
                    life: journalElements.scores.life.value
                });

                const payload = {
                    diaryDate: journalElements.date ? journalElements.date.value : null,
                    title: journalElements.title ? journalElements.title.value : 'ÁÑ°È°å',
                    tags: journalElements.tags ? journalElements.tags.value : '',
                    content: journalElements.content.value,
                    declaration: journalElements.declaration ? journalElements.declaration.value : '',
                    calendar: journalElements.calendar ? journalElements.calendar.value : '',
                    tasks: journalElements.todo ? journalElements.todo.value : '',
                    activity: journalElements.activity ? journalElements.activity.value : '',
                    redo: journalElements.redo ? journalElements.redo.value : '',
                    confidence: journalElements.confidence ? journalElements.confidence.value : '',
                    routine: fullRoutineLog,
                    scores: scoresJson
                };

                updateJournalStatus('‰øùÂ≠ò‰∏≠...');
                chrome.runtime.sendMessage({ type: 'save-diary', ...payload }, (res) => {
                    if (res && res.success) {
                        // DEBUG message removed

                        updateJournalStatus('GAS‰øùÂ≠òÂÆå‰∫Ü„ÄÇÂêåÊúü‰∏≠...');
                        chrome.runtime.sendMessage({ type: 'sync-notebooklm' }, (sRes) => {
                            if (sRes && sRes.success) {
                                updateJournalStatus('ÂÆå‰∫ÜÔºÅ');
                                alert('‰øùÂ≠ò„ÉªÂêåÊúüÂÆå‰∫Ü');
                            } else {
                                updateJournalStatus('ÂêåÊúüÂ§±Êïó', true);
                                alert('GAS„Å∏„ÅÆ‰øùÂ≠ò„ÅØÊàêÂäü„Åó„Åæ„Åó„Åü„Åå„ÄÅNotebookLM„Å∏„ÅÆÂêåÊúü„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ\nË®≠ÂÆö„Å™„Å©„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
                            }
                        });
                    } else {
                        updateJournalStatus('‰øùÂ≠òÂ§±Êïó', true);
                        alert('GAS„Å∏„ÅÆ‰øùÂ≠ò„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ' + (res?.error || '‰∏çÊòé'));
                    }
                });
            });
        }
        // ========================================
        // SUPPORTERS SECTION
        // ========================================
        function initSupporters() {
            // Load saved data
            for (let i = 1; i <= 4; i++) {
                const supporter = appState.supporters[i - 1] || { name: '', do: '', dont: '' };
                const nameEl = document.getElementById(`supporter-${i}-name`);
                const doEl = document.getElementById(`supporter-${i}-do`);
                const dontEl = document.getElementById(`supporter-${i}-dont`);

                if (nameEl) nameEl.value = supporter.name || '';
                if (doEl) doEl.value = supporter.do || '';
                if (dontEl) dontEl.value = supporter.dont || '';
            }

            // Save button
            const saveBtn = document.getElementById('save-supporters');
            if (saveBtn) {
                saveBtn.addEventListener('click', () => {
                    for (let i = 1; i <= 4; i++) {
                        const nameEl = document.getElementById(`supporter-${i}-name`);
                        const doEl = document.getElementById(`supporter-${i}-do`);
                        const dontEl = document.getElementById(`supporter-${i}-dont`);

                        appState.supporters[i - 1] = {
                            name: nameEl?.value || '',
                            do: doEl?.value || '',
                            dont: dontEl?.value || ''
                        };
                    }
                    saveState();
                    alert('ÊîØÊè¥ËÄÖÊÉÖÂ†±„Çí‰øùÂ≠ò„Åó„Åæ„Åó„ÅüÔºÅ');
                });
            }
        }

        // ========================================
        // MENTAL CONTROL SECTION
        // ========================================
        function initMental() {
            // Load saved data
            const declarationEl = document.getElementById('mental-declaration');
            const selftalkEl = document.getElementById('mental-selftalk');
            const improvementEl = document.getElementById('mental-improvement');
            const resetEl = document.getElementById('mental-reset');

            if (declarationEl) declarationEl.value = appState.mental?.declaration || '';
            if (selftalkEl) selftalkEl.value = appState.mental?.selftalk || '';
            if (improvementEl) improvementEl.value = appState.mental?.improvement || '';
            if (resetEl) resetEl.value = appState.mental?.reset || '';

            // Save button
            const saveBtn = document.getElementById('save-mental');
            if (saveBtn) {
                saveBtn.addEventListener('click', () => {
                    appState.mental = {
                        declaration: declarationEl?.value || '',
                        selftalk: selftalkEl?.value || '',
                        improvement: improvementEl?.value || '',
                        reset: resetEl?.value || ''
                    };
                    saveState();
                    alert('„É°„É≥„Çø„É´ÁÆ°ÁêÜË®≠ÂÆö„Çí‰øùÂ≠ò„Åó„Åæ„Åó„ÅüÔºÅ');
                });
            }
        }

        // ========================================
        // HABIT LOG SECTION
        // ========================================
        function initHabitLog() {
            // Populate Time Selects (15min intervals)
            ['habit-wakeup', 'habit-bedtime'].forEach(id => {
                const sel = document.getElementById(id);
                if (!sel) return;
                sel.innerHTML = '<option value="">--:--</option>';
                for (let h = 0; h < 24; h++) {
                    for (let m = 0; m < 60; m += 15) {
                        const hh = String(h).padStart(2, '0');
                        const mm = String(m).padStart(2, '0');
                        const val = `${hh}:${mm}`;
                        const ampm = h < 12 ? 'ÂçàÂâç' : 'ÂçàÂæå';
                        const dispH = h % 12 || 12;
                        const disp = `${ampm}${dispH}:${mm}`;
                        const opt = document.createElement('option');
                        opt.value = val;
                        opt.textContent = disp;
                        sel.appendChild(opt);
                    }
                }
            });

            // Stretch Checkbox Listener (UI Toggle)
            const h = habitElements;
            if (h.stretchCheck) {
                h.stretchCheck.addEventListener('change', (e) => {
                    if (h.stretchLabel) {
                        h.stretchLabel.textContent = e.target.checked ? 'ÂÆüÊñΩÊ∏à„Åø' : 'Êú™ÂÆüÊñΩ';
                    }
                });
            }

            // Save Button
            const saveBtn = document.getElementById('save-habits');

            if (saveBtn) {
                saveBtn.addEventListener('click', () => {
                    // Use currently selected date
                    const dateKey = journalElements.date ? journalElements.date.value : new Date().toISOString().split('T')[0];
                    const currentLog = appState.logs[dateKey] || {};

                    // Generate Muscle Text
                    let genText = '';
                    const detailContainer = document.getElementById('muscle-details-container');
                    if (detailContainer) {
                        detailContainer.querySelectorAll('.muscle-detail-row').forEach(row => {
                            const w = row.querySelector('.weight-select')?.value || '';
                            const s = row.querySelector('.sets-select')?.value || '';
                            if (row.dataset.name) genText += `${row.dataset.name}: ${w} ${s}\n`;
                        });
                    }

                    const memo = h.muscleDetail?.value || '';
                    const finalDetail = (genText.trim() + (memo ? `\n--- „É°„É¢ ---\n${memo}` : '')).trim();

                    currentLog.habits = {
                        wakeup: h.wakeup?.value || '',
                        bedtime: h.bedtime?.value || '',
                        englishContent: getChipValues(h.englishContentId),
                        englishTime: h.englishTime?.value || '',
                        muscleMenu: getChipValues(h.muscleMenuId),
                        muscleDetail: finalDetail,
                        joggingDist: h.joggingDist?.value || '',
                        joggingTime: h.joggingTime?.value || '',
                        stretchCheck: h.stretchCheck?.checked || false,
                        socialMenu: getChipValues(h.socialMenuId)
                    };

                    appState.logs[dateKey] = currentLog;
                    saveState();
                    alert(`ÁøíÊÖ£„É≠„Ç∞„Çí‰øùÂ≠ò„Åó„Åæ„Åó„ÅüÔºÅ (${dateKey})`);
                });
            }
        }

        // Init
        loadState();
        initGoalForm();
        renderSprintGoals();
        updateDashboard();
        renderMandala();
        // renderRoutines(); // replaced by matrix
        renderRoutineMatrix();
        initSupporters();
        initMental();
        initHabitLog();

        // --- Dashboard / Analysis Manager ---
        const dashboardManager = {
            data: [], // Cache for fetched data
            chartInstance: null,

            init: function () {
                this.setupTabs();
                this.setupRefresh();
            },

            setupTabs: function () {
                const tabs = document.querySelectorAll('.dash-tab-btn');
                tabs.forEach(tab => {
                    tab.addEventListener('click', () => {
                        // Switch UI
                        document.querySelectorAll('.dash-tab-btn').forEach(b => b.classList.remove('active'));
                        tab.classList.add('active');

                        const targetId = tab.dataset.tab;
                        // Hide all panels
                        document.querySelectorAll('.dashboard-panel').forEach(p => p.classList.remove('active'));
                        // Show target
                        const panel = document.getElementById(`panel-${targetId}`);
                        if (panel) panel.classList.add('active');

                        // If analysis tab, fetch data if empty
                        if (targetId === 'analysis' && this.data.length === 0) {
                            this.fetchData();
                        }
                    });
                });
            },

            setupRefresh: function () {
                const btn = document.getElementById('btn-refresh-data');
                if (btn) {
                    btn.addEventListener('click', () => {
                        this.fetchData();
                    });
                }
            },

            fetchData: async function () {
                const container = document.getElementById('habit-matrix-view');
                if (container) container.innerHTML = '<div class="loading-spinner"><i class="fa-solid fa-spinner fa-spin"></i> „Éá„Éº„Çø„ÇíË™≠„ÅøËæº„Åø‰∏≠...</div>';

                try {
                    // Use the GAS Web App URL
                    if (!CONFIG || !CONFIG.GAS_API_URL) {
                        throw new Error('GAS API URL not configured');
                    }

                    const response = await fetch(`${CONFIG.GAS_API_URL}?action=getAllHabitData`);
                    const result = await response.json();

                    if (result.success) {
                        this.data = result.data; // [{date, scores, routine}, ...]
                        this.renderAll();
                    } else {
                        throw new Error(result.message || 'Unknown error');
                    }

                } catch (e) {
                    console.error('Fetch error:', e);
                    if (container) container.innerHTML = `<div class="error-msg" style="text-align:center; padding:2rem; color:#ff6b6b">„Éá„Éº„Çø„ÅÆÂèñÂæó„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ<br>${e.message}</div>`;
                }
            },

            renderAll: function () {
                this.renderMatrix();
                this.renderRadar();
                this.renderStreaks();
            },

            // --- 1. Habit Matrix ---
            renderMatrix: function () {
                const container = document.getElementById('habit-matrix-view');
                if (!container) return;

                // Prepare Columns: Last 14 days
                const dates = [];
                for (let i = 13; i >= 0; i--) {
                    const d = new Date();
                    d.setDate(d.getDate() - i);
                    dates.push(this.formatDateShort(d)); // "1/22"
                }

                // Habits Definition
                const habits = [
                    { id: 'muscle', name: 'Á≠ã„Éà„É¨', key: '[Á≠ã„Éà„É¨]' },
                    { id: 'english', name: 'Ëã±‰ºöË©±/Â≠¶Áøí', key: ['[Ëã±Ë™û]', '[English]'] },
                    { id: 'note', name: 'Note/Áô∫‰ø°', key: ['[Note]', '[Áô∫‰ø°]', 'note'] },
                    { id: 'early', name: 'Êó©ÂØùÊó©Ëµ∑„Åç', key: '[Áù°Áú†]' },
                    { id: 'jog', name: '„Ç∏„Éß„ÇÆ„É≥„Ç∞', key: '[Jog]' },
                    { id: 'stretch', name: '„Çπ„Éà„É¨„ÉÉ„ÉÅ', key: '[„Çπ„Éà„É¨„ÉÉ„ÉÅ]' }
                ];

                // Build Table HTML
                let html = '<table class="habit-matrix-table"><thead><tr><th class="habit-col">ÁøíÊÖ£È†ÖÁõÆ</th>';
                dates.forEach(d => {
                    html += `<th>${d}</th>`;
                });
                html += '</tr></thead><tbody>';

                habits.forEach(habit => {
                    html += `<tr><td class="habit-col">${habit.name}</td>`;

                    dates.forEach(dateStr => {
                        const log = this.findLogByDate(dateStr);

                        let cellContent = '<i class="fa-regular fa-circle matrix-cell miss"></i>';

                        if (log) {
                            const routineText = (log.routine || '').toString();
                            if (routineText.includes('„Åä‰ºë„Åø')) {
                                cellContent = '<i class="fa-solid fa-moon matrix-cell rest"></i>';
                            } else {
                                let isDone = false;
                                const keys = Array.isArray(habit.key) ? habit.key : [habit.key];
                                for (const k of keys) {
                                    if (routineText.includes(k)) {
                                        isDone = true;
                                        break;
                                    }
                                }

                                if (isDone) {
                                    cellContent = '<i class="fa-solid fa-circle-check matrix-cell done"></i>';
                                }
                            }
                        }
                        html += `<td>${cellContent}</td>`;
                    });
                    html += '</tr>';
                });
                html += '</tbody></table>';

                container.innerHTML = html;
            },

            findLogByDate: function (shortDate) {
                // shortDate "1/23". log.date "2026-01-23T..." or "2026-01-23"
                // Match M/D
                return this.data.find(d => {
                    if (!d.date) return false;
                    const dObj = new Date(d.date);
                    const md = `${dObj.getMonth() + 1}/${dObj.getDate()}`;
                    return md === shortDate;
                });
            },

            formatDateShort: function (dateObj) {
                return `${dateObj.getMonth() + 1}/${dateObj.getDate()}`;
            },

            // --- 2. Radar Chart ---
            renderRadar: function () {
                const ctx = document.getElementById('radarChart');
                if (!ctx) return;

                const last7 = this.data.slice(-7);
                let sums = { heart: 0, skill: 0, body: 0, life: 0, count: 0 };

                last7.forEach(log => {
                    if (log.scores) {
                        try {
                            let s = log.scores;
                            if (typeof s === 'string') {
                                // GAS might return object inside string or object
                                // If it's pure JSON string
                                try { s = JSON.parse(s); } catch (ex) { }
                            }

                            sums.heart += parseInt(s.heart || 0);
                            sums.skill += parseInt(s.skill || 0);
                            sums.body += parseInt(s.body || 0);
                            sums.life += parseInt(s.life || 0);
                            sums.count++;
                        } catch (e) { }
                    }
                });

                const avg = (val) => sums.count > 0 ? (val / sums.count).toFixed(1) : 0;
                const dataset = [avg(sums.heart), avg(sums.skill), avg(sums.body), avg(sums.life)];

                if (this.chartInstance) {
                    this.chartInstance.destroy();
                }

                this.chartInstance = new Chart(ctx, {
                    type: 'radar',
                    data: {
                        labels: ['ÂøÉ (Heart)', 'ÊäÄ (Skill)', '‰Ωì (Body)', 'ÁîüÊ¥ª (Life)'],
                        datasets: [{
                            label: 'Áõ¥Ëøë1ÈÄ±Èñì„ÅÆÂπ≥Âùá',
                            data: dataset,
                            backgroundColor: 'rgba(255, 215, 0, 0.2)',
                            borderColor: '#FFD700',
                            pointBackgroundColor: '#FFD700',
                            pointBorderColor: '#fff',
                            pointHoverBackgroundColor: '#fff',
                            pointHoverBorderColor: '#FFD700'
                        }]
                    },
                    options: {
                        scales: {
                            r: {
                                angleLines: { color: 'rgba(255,255,255,0.1)' },
                                grid: { color: 'rgba(255,255,255,0.1)' },
                                pointLabels: { color: '#ccc', font: { size: 12 } },
                                ticks: { display: false, max: 5, min: 0 }
                            }
                        },
                        plugins: {
                            legend: { display: false }
                        },
                        maintainAspectRatio: false
                    }
                });
            },

            // --- 3. Streak Calculation ---
            renderStreaks: function () {
                const container = document.getElementById('streak-list-view');
                if (!container) return;

                const habits = [
                    { id: 'english', name: 'Ëã±Ë™ûÂ≠¶Áøí', key: ['[Ëã±Ë™û]', '[English]'] },
                    { id: 'muscle', name: 'Á≠ã„Éà„É¨', key: '[Á≠ã„Éà„É¨]' },
                    { id: 'jog', name: '„Ç∏„Éß„ÇÆ„É≥„Ç∞', key: '[Jog]' },
                    { id: 'daily', name: 'Êó•Ë™åË®òÂÖ•', key: null }
                ];

                let html = '';
                // Clone and sort desc
                // If data from GAS is [old, ..., new], reverse it to [new, ..., old]
                const reversedData = [...this.data].reverse();

                habits.forEach(h => {
                    let streak = 0;
                    // Start checking from index 0 (newest)
                    // Caution: if today is empty, streak might be broken 0.
                    // But maybe user hasn't inputted today yet. 
                    // Strict streak: break on first miss.
                    for (let i = 0; i < reversedData.length; i++) {
                        const log = reversedData[i];
                        const routineText = (log.routine || '').toString();
                        let isDone = false;

                        if (h.key === null) {
                            isDone = !!log.date; // Just existence
                        } else {
                            const keys = Array.isArray(h.key) ? h.key : [h.key];
                            for (const k of keys) {
                                if (routineText.includes(k) && !routineText.includes('„Åä‰ºë„Åø')) {
                                    isDone = true;
                                    break;
                                }
                            }
                        }

                        if (isDone) streak++;
                        else {
                            // If today (i=0) is missed, and it's morning? 
                            // For simplicity, strict streak.
                            // If i=0 (today) is miss, streak is 0?
                            // Maybe check yesterdays streak if today is empty?
                            // Let's keep it strict "Current Streak" includes most recent contiguous block.
                            // If today is NOT done, but yesterday IS, streak is still valid technically until day end.
                            // But here we just count from newest log back until break.
                            // If newest log (yesterday) is done, streak is N.
                            // If newest log (today) is miss, streak is 0.
                            // This is fine. 'Don't break the chain'.
                            break;
                        }
                    }

                    const iconClass = streak > 0 ? 'fire' : 'ice';
                    const iconColor = streak > 0 ? '#FF5722' : '#90A4AE';
                    const icon = streak > 0 ? 'fa-fire' : 'fa-snowflake';

                    html += `
                    <div class="streak-item ${iconClass}">
                        <div class="streak-name">
                            <i class="fa-solid ${icon} streak-icon" style="color:${iconColor}"></i>
                            ${h.name}
                        </div>
                        <div class="streak-count">${streak} <span style="font-size:0.8rem; font-weight:normal;">days</span></div>
                    </div>`;
                });

                container.innerHTML = html;
            }
        };

        // Init Dashboard
        dashboardManager.init();

    } catch (e) {
        console.error('Fatal Init Error:', e);
        alert('Ëµ∑Âãï„Ç®„É©„Éº: ' + e.message);
    }
});
